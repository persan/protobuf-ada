-- Generated by the protocol buffer compiler.  DO NOT EDIT!
-- source: unittest.proto

pragma Ada_2012;

package body Unittest.TestFieldOrderings is
  ---------------------------------------------------------------------------
  -- Inherited functions and procedures from Protocol_Buffers.Message -------
  ---------------------------------------------------------------------------

  procedure Clear
    (The_Message : in out Unittest.TestFieldOrderings.Instance) is
  begin
    if (The_Message.Has_Bits (0 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 0 mod 32)) /= 0 then
      if The_Message.Has_My_String then
        The_Message.Clear_Has_My_String;
        declare
          procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
        begin
          if The_Message.My_String /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
            Free (The_Message.My_String);
          end if;
        end;
        The_Message.My_String := Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access;
      end if;
      The_Message.My_Int := 0;
      The_Message.My_Float := Protocol_Buffers.Wire_Format.PB_Float (0.00000);
    end if;
    The_Message.Has_Bits := (others => 0);
  end Clear;

  procedure Copy
    (To   : in out Unittest.TestFieldOrderings.Instance;
     From : in Unittest.TestFieldOrderings.Instance) is
  begin
    To.Clear;
    To.Merge (From);
  end Copy;

  function Get_Type_Name
    (The_Message : in Unittest.TestFieldOrderings.Instance) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return "protobuf_unittest.TestFieldOrderings";
  end Get_Type_Name;

  function Is_Initialized
    (The_Message : in Unittest.TestFieldOrderings.Instance) return Boolean is
  begin
    return True;
  end Is_Initialized;

  procedure Merge
    (To   : in out Unittest.TestFieldOrderings.Instance;
     From : in Unittest.TestFieldOrderings.Instance) is
  begin
    if (From.Has_Bits (0 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 0 mod 32)) /= 0 then
      -- optional string my_string = 11;
      if From.Has_My_String then
        To.Set_My_String(From.Get_My_String);
      end if;
      -- optional int64 my_int = 1;
      if From.Has_My_Int then
        To.Set_My_Int (From.My_Int);
      end if;
      -- optional float my_float = 101;
      if From.Has_My_Float then
        To.Set_My_Float (From.My_Float);
      end if;
    end if;
  end Merge;

  function Byte_Size
    (The_Message : in out Unittest.TestFieldOrderings.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
    Total_Size : Protocol_Buffers.Wire_Format.PB_Object_Size := 0;
  begin
    if (The_Message.Has_Bits (0 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 0 mod 32)) /= 0 then
      -- optional string my_string = 11;
      if The_Message.Has_My_String then
        Total_Size := Total_Size + 1 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.My_String.all);
      end if;
      -- optional int64 my_int = 1;
      if The_Message.Has_My_Int then
        Total_Size := Total_Size + 1 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_64_Size_No_Tag (The_Message.My_Int);
      end if;
      -- optional float my_float = 101;
      if The_Message.Has_My_Float then
        Total_Size := Total_Size + 2 + 4;
      end if;
    end if;
    The_Message.Cached_Size := Total_Size;
    return Total_Size;
  end Byte_Size;

  procedure Serialize_With_Cached_Sizes
    (The_Message   : in Unittest.TestFieldOrderings.Instance;
     The_Coded_Output_Stream : in
       Protocol_Buffers.IO.Coded_Output_Stream.Instance) is
  begin
    -- optional int64 my_int = 1;
    if The_Message.Has_My_Int then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Integer_64 (The_Coded_Output_Stream, 1, The_Message.My_Int);
    end if;
    -- optional string my_string = 11;
    if The_Message.Has_My_String then
      The_Coded_Output_Stream.Write_String (11, The_Message.My_String.all);
    end if;
    -- optional float my_float = 101;
    if The_Message.Has_My_Float then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Float (The_Coded_Output_Stream, 101, The_Message.My_Float);
    end if;
  end Serialize_With_Cached_Sizes;

  procedure Merge_Partial_From_Coded_Input_Stream
    (The_Message   : in out Unittest.TestFieldOrderings.Instance;
     The_Coded_Input_Stream : in out
       Protocol_Buffers.IO.Coded_Input_Stream.Instance) is
    Tag : Protocol_Buffers.Wire_Format.PB_UInt32;
  begin
    Tag := The_Coded_Input_Stream.Read_Tag;
    while Tag /= 0 loop
      case Protocol_Buffers.Wire_Format.Get_Tag_Field_Number (Tag) is
      -- optional int64 my_int = 1;
      when 1 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.My_Int := The_Coded_Input_Stream.Read_Integer_64;
          The_Message.Set_Has_My_Int;
        end if;
      -- optional string my_string = 11;
      when 11 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
          begin
            if The_Message.My_String /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
              Free (The_Message.My_String);
            end if;
          end;
          The_Message.Set_Has_My_String;
          The_Message.My_String := The_Coded_Input_Stream.Read_String;
        end if;
      -- optional float my_float = 101;
      when 101 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.My_Float := The_Coded_Input_Stream.Read_Float;
          The_Message.Set_Has_My_Float;
        end if;
      when others =>
        declare
          Dummy : Protocol_Buffers.Wire_Format.PB_Bool;
          pragma Unreferenced (Dummy);
        begin
          Dummy := The_Coded_Input_Stream.Skip_Field (Tag);
          return;
        end;
      end case;
      Tag := The_Coded_Input_Stream.Read_Tag;
    end loop;
  end Merge_Partial_From_Coded_Input_Stream;

  function Get_Cached_Size
    (The_Message : in Unittest.TestFieldOrderings.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return The_Message.Cached_Size;
  end Get_Cached_Size;

  overriding
  procedure Finalize
    (The_Message : in out Unittest.TestFieldOrderings.Instance) is
  begin
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.My_String /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
        Free (The_Message.My_String);
      end if;
    end;
  end Finalize;

  ---------------------------------------------------------------------------
  -- Field accessor definitions ---------------------------------------------
  ---------------------------------------------------------------------------

  -- optional string my_string = 11;
  function Has_My_String
    (The_Message : in TestFieldOrderings.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000001#) /= 0;
  end Has_My_String;

  procedure Set_Has_My_String
    (The_Message : in out TestFieldOrderings.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000001#;
  end Set_Has_My_String;

  procedure Clear_Has_My_String
    (The_Message : in out TestFieldOrderings.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000001#);
  end Clear_Has_My_String;

  procedure Clear_My_String
    (The_Message : in out TestFieldOrderings.Instance) is
  begin
    The_Message.Clear_Has_My_String;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.My_String /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
        Free (The_Message.My_String);
      end if;
    end;
    The_Message.My_String := Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access;
    The_Message.Clear_Has_My_String;
  end Clear_My_String;

  function Get_My_String
    (The_Message : in TestFieldOrderings.Instance) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.My_String.all;
  end Get_My_String;

  function Get_My_String
    (The_Message : in out TestFieldOrderings.Instance;
     Size : in Integer := -1) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Set_Has_My_String;
    if Size >= 0 then
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.My_String /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.My_String);
        end if;
      end;
      The_Message.My_String := new Protocol_Buffers.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
      return The_Message.My_String;
    end if;

    if The_Message.My_String = Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
      The_Message.My_String := new String'(Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING);
    end if;
    return The_Message.My_String;
  end Get_My_String;

  procedure Set_My_String
    (The_Message : in out TestFieldOrderings.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Set_Has_My_String;
    if The_Message.My_String /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access and then Value'Length = The_Message.My_String.all'Length then
      The_Message.My_String.all := Value;
    else
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.My_String /= Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.My_String);
        end if;
      end;
      The_Message.My_String := new Protocol_Buffers.Wire_Format.PB_String'(Value);
    end if;
  end Set_My_String;

  function Release_My_String
    (The_Message : in out TestFieldOrderings.Instance) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Clear_Has_My_String;
    if The_Message.My_String = Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access then
      return null;
    else
      declare
        Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.My_String;
      begin
        The_Message.My_String := Protocol_Buffers.Generated_Message_Utilities.EMPTY_STRING'Access;
        return Temp;
      end;
    end if;
  end Release_My_String;

  -- optional int64 my_int = 1;
  function Has_My_Int
    (The_Message : in TestFieldOrderings.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000002#) /= 0;
  end Has_My_Int;

  procedure Set_Has_My_Int
    (The_Message : in out TestFieldOrderings.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000002#;
  end Set_Has_My_Int;

  procedure Clear_Has_My_Int
    (The_Message : in out TestFieldOrderings.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000002#);
  end Clear_Has_My_Int;

  procedure Clear_My_Int
    (The_Message : in out TestFieldOrderings.Instance) is
  begin
    The_Message.My_Int := 0;
    The_Message.Clear_Has_My_Int;
  end Clear_My_Int;

  function Get_My_Int
    (The_Message : in TestFieldOrderings.Instance) return Protocol_Buffers.Wire_Format.PB_Int64 is
  begin
    return The_Message.My_Int;
  end Get_My_Int;

  procedure Set_My_Int
    (The_Message : in out TestFieldOrderings.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int64) is
  begin
    The_Message.Set_Has_My_Int;
    The_Message.My_Int := Value;
  end Set_My_Int;

  -- optional float my_float = 101;
  function Has_My_Float
    (The_Message : in TestFieldOrderings.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000004#) /= 0;
  end Has_My_Float;

  procedure Set_Has_My_Float
    (The_Message : in out TestFieldOrderings.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000004#;
  end Set_Has_My_Float;

  procedure Clear_Has_My_Float
    (The_Message : in out TestFieldOrderings.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000004#);
  end Clear_Has_My_Float;

  procedure Clear_My_Float
    (The_Message : in out TestFieldOrderings.Instance) is
  begin
    The_Message.My_Float := Protocol_Buffers.Wire_Format.PB_Float (0.00000);
    The_Message.Clear_Has_My_Float;
  end Clear_My_Float;

  function Get_My_Float
    (The_Message : in TestFieldOrderings.Instance) return Protocol_Buffers.Wire_Format.PB_Float is
  begin
    return The_Message.My_Float;
  end Get_My_Float;

  procedure Set_My_Float
    (The_Message : in out TestFieldOrderings.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Float) is
  begin
    The_Message.Set_Has_My_Float;
    The_Message.My_Float := Value;
  end Set_My_Float;

end Unittest.TestFieldOrderings;
