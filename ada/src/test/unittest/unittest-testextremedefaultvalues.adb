-- Generated by the protocol buffer compiler.  DO NOT EDIT!
-- source: unittest.proto

pragma Ada_2012;

package body Unittest.TestExtremeDefaultValues is
  ---------------------------------------------------------------------------
  -- Inherited functions and procedures from Protocol_Buffers.Message -------
  ---------------------------------------------------------------------------

  procedure Clear
    (The_Message : in out Unittest.TestExtremeDefaultValues.Instance) is
  begin
    if (The_Message.Has_Bits (0 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 0 mod 32)) /= 0 then
      if The_Message.Has_Escaped_Bytes then
        The_Message.Clear_Has_Escaped_Bytes;
        declare
          procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
        begin
          if The_Message.Escaped_Bytes /= Default_Escaped_Bytes'Access then
            Free (The_Message.Escaped_Bytes);
          end if;
        end;
        The_Message.Escaped_Bytes := Default_Escaped_Bytes'Access;
      end if;
      The_Message.Large_Uint32 := 4294967295;
      The_Message.Large_Uint64 := 18446744073709551615;
      The_Message.Small_Int32 := -2147483647;
      The_Message.Small_Int64 := -9223372036854775807;
      The_Message.Really_Small_Int32 := -2147483648;
      The_Message.Really_Small_Int64 := -9223372036854775808;
      if The_Message.Has_Utf8_String then
        The_Message.Clear_Has_Utf8_String;
        declare
          procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
        begin
          if The_Message.Utf8_String /= Default_Utf8_String'Access then
            Free (The_Message.Utf8_String);
          end if;
        end;
        The_Message.Utf8_String := Default_Utf8_String'Access;
      end if;
    end if;
    if (The_Message.Has_Bits (8 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 8 mod 32)) /= 0 then
      The_Message.Zero_Float := Protocol_Buffers.Wire_Format.PB_Float (0.00000);
      The_Message.One_Float := Protocol_Buffers.Wire_Format.PB_Float (1.00000);
      The_Message.Small_Float := Protocol_Buffers.Wire_Format.PB_Float (1.50000);
      The_Message.Negative_One_Float := Protocol_Buffers.Wire_Format.PB_Float (-1.00000);
      The_Message.Negative_Float := Protocol_Buffers.Wire_Format.PB_Float (-1.50000);
      The_Message.Large_Float := Protocol_Buffers.Wire_Format.PB_Float (2.00000e+08);
      The_Message.Small_Negative_Float := Protocol_Buffers.Wire_Format.PB_Float (-8.00000e-28);
      The_Message.Inf_Double := Protocol_Buffers.Generated_Message_Utilities.Positive_Infinity;
    end if;
    if (The_Message.Has_Bits (16 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 16 mod 32)) /= 0 then
      The_Message.Neg_Inf_Double := Protocol_Buffers.Generated_Message_Utilities.Negative_Infinity;
      The_Message.Nan_Double := Protocol_Buffers.Generated_Message_Utilities.NaN;
      The_Message.Inf_Float := Protocol_Buffers.Generated_Message_Utilities.Positive_Infinity;
      The_Message.Neg_Inf_Float := Protocol_Buffers.Generated_Message_Utilities.Negative_Infinity;
      The_Message.Nan_Float := Protocol_Buffers.Generated_Message_Utilities.NaN;
      if The_Message.Has_Cpp_Trigraph then
        The_Message.Clear_Has_Cpp_Trigraph;
        declare
          procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
        begin
          if The_Message.Cpp_Trigraph /= Default_Cpp_Trigraph'Access then
            Free (The_Message.Cpp_Trigraph);
          end if;
        end;
        The_Message.Cpp_Trigraph := Default_Cpp_Trigraph'Access;
      end if;
      if The_Message.Has_String_With_Zero then
        The_Message.Clear_Has_String_With_Zero;
        declare
          procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
        begin
          if The_Message.String_With_Zero /= Default_String_With_Zero'Access then
            Free (The_Message.String_With_Zero);
          end if;
        end;
        The_Message.String_With_Zero := Default_String_With_Zero'Access;
      end if;
      if The_Message.Has_Bytes_With_Zero then
        The_Message.Clear_Has_Bytes_With_Zero;
        declare
          procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
        begin
          if The_Message.Bytes_With_Zero /= Default_Bytes_With_Zero'Access then
            Free (The_Message.Bytes_With_Zero);
          end if;
        end;
        The_Message.Bytes_With_Zero := Default_Bytes_With_Zero'Access;
      end if;
    end if;
    if (The_Message.Has_Bits (24 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 24 mod 32)) /= 0 then
      if The_Message.Has_String_Piece_With_Zero then
        The_Message.Clear_Has_String_Piece_With_Zero;
        declare
          procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
        begin
          if The_Message.String_Piece_With_Zero /= Default_String_Piece_With_Zero'Access then
            Free (The_Message.String_Piece_With_Zero);
          end if;
        end;
        The_Message.String_Piece_With_Zero := Default_String_Piece_With_Zero'Access;
      end if;
      if The_Message.Has_Cord_With_Zero then
        The_Message.Clear_Has_Cord_With_Zero;
        declare
          procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
        begin
          if The_Message.Cord_With_Zero /= Default_Cord_With_Zero'Access then
            Free (The_Message.Cord_With_Zero);
          end if;
        end;
        The_Message.Cord_With_Zero := Default_Cord_With_Zero'Access;
      end if;
    end if;
    The_Message.Has_Bits := (others => 0);
  end Clear;

  procedure Copy
    (To   : in out Unittest.TestExtremeDefaultValues.Instance;
     From : in Unittest.TestExtremeDefaultValues.Instance) is
  begin
    To.Clear;
    To.Merge (From);
  end Copy;

  function Get_Type_Name
    (The_Message : in Unittest.TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return "protobuf_unittest.TestExtremeDefaultValues";
  end Get_Type_Name;

  function Is_Initialized
    (The_Message : in Unittest.TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return True;
  end Is_Initialized;

  procedure Merge
    (To   : in out Unittest.TestExtremeDefaultValues.Instance;
     From : in Unittest.TestExtremeDefaultValues.Instance) is
  begin
    if (From.Has_Bits (0 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 0 mod 32)) /= 0 then
      -- optional bytes escaped_bytes = 1 [default = "\000\001\007\010\014\n\r\t\013\\\'\"\376"];
      if From.Has_Escaped_Bytes then
        To.Set_Escaped_Bytes(From.Get_Escaped_Bytes);
      end if;
      -- optional uint32 large_uint32 = 2 [default = 4294967295];
      if From.Has_Large_Uint32 then
        To.Set_Large_Uint32 (From.Large_Uint32);
      end if;
      -- optional uint64 large_uint64 = 3 [default = 18446744073709551615];
      if From.Has_Large_Uint64 then
        To.Set_Large_Uint64 (From.Large_Uint64);
      end if;
      -- optional int32 small_int32 = 4 [default = -2147483647];
      if From.Has_Small_Int32 then
        To.Set_Small_Int32 (From.Small_Int32);
      end if;
      -- optional int64 small_int64 = 5 [default = -9223372036854775807];
      if From.Has_Small_Int64 then
        To.Set_Small_Int64 (From.Small_Int64);
      end if;
      -- optional int32 really_small_int32 = 21 [default = -2147483648];
      if From.Has_Really_Small_Int32 then
        To.Set_Really_Small_Int32 (From.Really_Small_Int32);
      end if;
      -- optional int64 really_small_int64 = 22 [default = -9223372036854775808];
      if From.Has_Really_Small_Int64 then
        To.Set_Really_Small_Int64 (From.Really_Small_Int64);
      end if;
      -- optional string utf8_string = 6 [default = "\341\210\264"];
      if From.Has_Utf8_String then
        To.Set_Utf8_String(From.Get_Utf8_String);
      end if;
    end if;
    if (From.Has_Bits (8 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 8 mod 32)) /= 0 then
      -- optional float zero_float = 7 [default = 0];
      if From.Has_Zero_Float then
        To.Set_Zero_Float (From.Zero_Float);
      end if;
      -- optional float one_float = 8 [default = 1];
      if From.Has_One_Float then
        To.Set_One_Float (From.One_Float);
      end if;
      -- optional float small_float = 9 [default = 1.5];
      if From.Has_Small_Float then
        To.Set_Small_Float (From.Small_Float);
      end if;
      -- optional float negative_one_float = 10 [default = -1];
      if From.Has_Negative_One_Float then
        To.Set_Negative_One_Float (From.Negative_One_Float);
      end if;
      -- optional float negative_float = 11 [default = -1.5];
      if From.Has_Negative_Float then
        To.Set_Negative_Float (From.Negative_Float);
      end if;
      -- optional float large_float = 12 [default = 2e+08];
      if From.Has_Large_Float then
        To.Set_Large_Float (From.Large_Float);
      end if;
      -- optional float small_negative_float = 13 [default = -8e-28];
      if From.Has_Small_Negative_Float then
        To.Set_Small_Negative_Float (From.Small_Negative_Float);
      end if;
      -- optional double inf_double = 14 [default = inf];
      if From.Has_Inf_Double then
        To.Set_Inf_Double (From.Inf_Double);
      end if;
    end if;
    if (From.Has_Bits (16 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 16 mod 32)) /= 0 then
      -- optional double neg_inf_double = 15 [default = -inf];
      if From.Has_Neg_Inf_Double then
        To.Set_Neg_Inf_Double (From.Neg_Inf_Double);
      end if;
      -- optional double nan_double = 16 [default = nan];
      if From.Has_Nan_Double then
        To.Set_Nan_Double (From.Nan_Double);
      end if;
      -- optional float inf_float = 17 [default = inf];
      if From.Has_Inf_Float then
        To.Set_Inf_Float (From.Inf_Float);
      end if;
      -- optional float neg_inf_float = 18 [default = -inf];
      if From.Has_Neg_Inf_Float then
        To.Set_Neg_Inf_Float (From.Neg_Inf_Float);
      end if;
      -- optional float nan_float = 19 [default = nan];
      if From.Has_Nan_Float then
        To.Set_Nan_Float (From.Nan_Float);
      end if;
      -- optional string cpp_trigraph = 20 [default = "? ? ?? ?? ??? ??/ ??-"];
      if From.Has_Cpp_Trigraph then
        To.Set_Cpp_Trigraph(From.Get_Cpp_Trigraph);
      end if;
      -- optional string string_with_zero = 23 [default = "hel\000lo"];
      if From.Has_String_With_Zero then
        To.Set_String_With_Zero(From.Get_String_With_Zero);
      end if;
      -- optional bytes bytes_with_zero = 24 [default = "wor\000ld"];
      if From.Has_Bytes_With_Zero then
        To.Set_Bytes_With_Zero(From.Get_Bytes_With_Zero);
      end if;
    end if;
    if (From.Has_Bits (24 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 24 mod 32)) /= 0 then
      -- optional string string_piece_with_zero = 25 [default = "ab\000c", ctype = STRING_PIECE];
      if From.Has_String_Piece_With_Zero then
        To.Set_String_Piece_With_Zero(From.Get_String_Piece_With_Zero);
      end if;
      -- optional string cord_with_zero = 26 [default = "12\0003", ctype = CORD];
      if From.Has_Cord_With_Zero then
        To.Set_Cord_With_Zero(From.Get_Cord_With_Zero);
      end if;
    end if;
  end Merge;

  function Byte_Size
    (The_Message : in out Unittest.TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
    Total_Size : Protocol_Buffers.Wire_Format.PB_Object_Size := 0;
  begin
    if (The_Message.Has_Bits (0 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 0 mod 32)) /= 0 then
      -- optional bytes escaped_bytes = 1 [default = "\000\001\007\010\014\n\r\t\013\\\'\"\376"];
      if The_Message.Has_Escaped_Bytes then
        Total_Size := Total_Size + 1 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.Escaped_Bytes.all);
      end if;
      -- optional uint32 large_uint32 = 2 [default = 4294967295];
      if The_Message.Has_Large_Uint32 then
        Total_Size := Total_Size + 1 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Unsigned_Integer_32_Size_No_Tag (The_Message.Large_Uint32);
      end if;
      -- optional uint64 large_uint64 = 3 [default = 18446744073709551615];
      if The_Message.Has_Large_Uint64 then
        Total_Size := Total_Size + 1 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Unsigned_Integer_64_Size_No_Tag (The_Message.Large_Uint64);
      end if;
      -- optional int32 small_int32 = 4 [default = -2147483647];
      if The_Message.Has_Small_Int32 then
        Total_Size := Total_Size + 1 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (The_Message.Small_Int32);
      end if;
      -- optional int64 small_int64 = 5 [default = -9223372036854775807];
      if The_Message.Has_Small_Int64 then
        Total_Size := Total_Size + 1 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_64_Size_No_Tag (The_Message.Small_Int64);
      end if;
      -- optional int32 really_small_int32 = 21 [default = -2147483648];
      if The_Message.Has_Really_Small_Int32 then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (The_Message.Really_Small_Int32);
      end if;
      -- optional int64 really_small_int64 = 22 [default = -9223372036854775808];
      if The_Message.Has_Really_Small_Int64 then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_Integer_64_Size_No_Tag (The_Message.Really_Small_Int64);
      end if;
      -- optional string utf8_string = 6 [default = "\341\210\264"];
      if The_Message.Has_Utf8_String then
        Total_Size := Total_Size + 1 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.Utf8_String.all);
      end if;
    end if;
    if (The_Message.Has_Bits (8 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 8 mod 32)) /= 0 then
      -- optional float zero_float = 7 [default = 0];
      if The_Message.Has_Zero_Float then
        Total_Size := Total_Size + 1 + 4;
      end if;
      -- optional float one_float = 8 [default = 1];
      if The_Message.Has_One_Float then
        Total_Size := Total_Size + 1 + 4;
      end if;
      -- optional float small_float = 9 [default = 1.5];
      if The_Message.Has_Small_Float then
        Total_Size := Total_Size + 1 + 4;
      end if;
      -- optional float negative_one_float = 10 [default = -1];
      if The_Message.Has_Negative_One_Float then
        Total_Size := Total_Size + 1 + 4;
      end if;
      -- optional float negative_float = 11 [default = -1.5];
      if The_Message.Has_Negative_Float then
        Total_Size := Total_Size + 1 + 4;
      end if;
      -- optional float large_float = 12 [default = 2e+08];
      if The_Message.Has_Large_Float then
        Total_Size := Total_Size + 1 + 4;
      end if;
      -- optional float small_negative_float = 13 [default = -8e-28];
      if The_Message.Has_Small_Negative_Float then
        Total_Size := Total_Size + 1 + 4;
      end if;
      -- optional double inf_double = 14 [default = inf];
      if The_Message.Has_Inf_Double then
        Total_Size := Total_Size + 1 + 8;
      end if;
    end if;
    if (The_Message.Has_Bits (16 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 16 mod 32)) /= 0 then
      -- optional double neg_inf_double = 15 [default = -inf];
      if The_Message.Has_Neg_Inf_Double then
        Total_Size := Total_Size + 1 + 8;
      end if;
      -- optional double nan_double = 16 [default = nan];
      if The_Message.Has_Nan_Double then
        Total_Size := Total_Size + 2 + 8;
      end if;
      -- optional float inf_float = 17 [default = inf];
      if The_Message.Has_Inf_Float then
        Total_Size := Total_Size + 2 + 4;
      end if;
      -- optional float neg_inf_float = 18 [default = -inf];
      if The_Message.Has_Neg_Inf_Float then
        Total_Size := Total_Size + 2 + 4;
      end if;
      -- optional float nan_float = 19 [default = nan];
      if The_Message.Has_Nan_Float then
        Total_Size := Total_Size + 2 + 4;
      end if;
      -- optional string cpp_trigraph = 20 [default = "? ? ?? ?? ??? ??/ ??-"];
      if The_Message.Has_Cpp_Trigraph then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.Cpp_Trigraph.all);
      end if;
      -- optional string string_with_zero = 23 [default = "hel\000lo"];
      if The_Message.Has_String_With_Zero then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.String_With_Zero.all);
      end if;
      -- optional bytes bytes_with_zero = 24 [default = "wor\000ld"];
      if The_Message.Has_Bytes_With_Zero then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.Bytes_With_Zero.all);
      end if;
    end if;
    if (The_Message.Has_Bits (24 / 32) and Protocol_Buffers.Wire_Format.Shift_Left (16#FF#, 24 mod 32)) /= 0 then
      -- optional string string_piece_with_zero = 25 [default = "ab\000c", ctype = STRING_PIECE];
      if The_Message.Has_String_Piece_With_Zero then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.String_Piece_With_Zero.all);
      end if;
      -- optional string cord_with_zero = 26 [default = "12\0003", ctype = CORD];
      if The_Message.Has_Cord_With_Zero then
        Total_Size := Total_Size + 2 + Protocol_Buffers.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.Cord_With_Zero.all);
      end if;
    end if;
    The_Message.Cached_Size := Total_Size;
    return Total_Size;
  end Byte_Size;

  procedure Serialize_With_Cached_Sizes
    (The_Message   : in Unittest.TestExtremeDefaultValues.Instance;
     The_Coded_Output_Stream : in
       Protocol_Buffers.IO.Coded_Output_Stream.Instance) is
  begin
    -- optional bytes escaped_bytes = 1 [default = "\000\001\007\010\014\n\r\t\013\\\'\"\376"];
    if The_Message.Has_Escaped_Bytes then
      The_Coded_Output_Stream.Write_String (1, The_Message.Escaped_Bytes.all);
    end if;
    -- optional uint32 large_uint32 = 2 [default = 4294967295];
    if The_Message.Has_Large_Uint32 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Unsigned_Integer_32 (The_Coded_Output_Stream, 2, The_Message.Large_Uint32);
    end if;
    -- optional uint64 large_uint64 = 3 [default = 18446744073709551615];
    if The_Message.Has_Large_Uint64 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Unsigned_Integer_64 (The_Coded_Output_Stream, 3, The_Message.Large_Uint64);
    end if;
    -- optional int32 small_int32 = 4 [default = -2147483647];
    if The_Message.Has_Small_Int32 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Integer_32 (The_Coded_Output_Stream, 4, The_Message.Small_Int32);
    end if;
    -- optional int64 small_int64 = 5 [default = -9223372036854775807];
    if The_Message.Has_Small_Int64 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Integer_64 (The_Coded_Output_Stream, 5, The_Message.Small_Int64);
    end if;
    -- optional string utf8_string = 6 [default = "\341\210\264"];
    if The_Message.Has_Utf8_String then
      The_Coded_Output_Stream.Write_String (6, The_Message.Utf8_String.all);
    end if;
    -- optional float zero_float = 7 [default = 0];
    if The_Message.Has_Zero_Float then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Float (The_Coded_Output_Stream, 7, The_Message.Zero_Float);
    end if;
    -- optional float one_float = 8 [default = 1];
    if The_Message.Has_One_Float then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Float (The_Coded_Output_Stream, 8, The_Message.One_Float);
    end if;
    -- optional float small_float = 9 [default = 1.5];
    if The_Message.Has_Small_Float then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Float (The_Coded_Output_Stream, 9, The_Message.Small_Float);
    end if;
    -- optional float negative_one_float = 10 [default = -1];
    if The_Message.Has_Negative_One_Float then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Float (The_Coded_Output_Stream, 10, The_Message.Negative_One_Float);
    end if;
    -- optional float negative_float = 11 [default = -1.5];
    if The_Message.Has_Negative_Float then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Float (The_Coded_Output_Stream, 11, The_Message.Negative_Float);
    end if;
    -- optional float large_float = 12 [default = 2e+08];
    if The_Message.Has_Large_Float then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Float (The_Coded_Output_Stream, 12, The_Message.Large_Float);
    end if;
    -- optional float small_negative_float = 13 [default = -8e-28];
    if The_Message.Has_Small_Negative_Float then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Float (The_Coded_Output_Stream, 13, The_Message.Small_Negative_Float);
    end if;
    -- optional double inf_double = 14 [default = inf];
    if The_Message.Has_Inf_Double then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Double (The_Coded_Output_Stream, 14, The_Message.Inf_Double);
    end if;
    -- optional double neg_inf_double = 15 [default = -inf];
    if The_Message.Has_Neg_Inf_Double then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Double (The_Coded_Output_Stream, 15, The_Message.Neg_Inf_Double);
    end if;
    -- optional double nan_double = 16 [default = nan];
    if The_Message.Has_Nan_Double then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Double (The_Coded_Output_Stream, 16, The_Message.Nan_Double);
    end if;
    -- optional float inf_float = 17 [default = inf];
    if The_Message.Has_Inf_Float then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Float (The_Coded_Output_Stream, 17, The_Message.Inf_Float);
    end if;
    -- optional float neg_inf_float = 18 [default = -inf];
    if The_Message.Has_Neg_Inf_Float then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Float (The_Coded_Output_Stream, 18, The_Message.Neg_Inf_Float);
    end if;
    -- optional float nan_float = 19 [default = nan];
    if The_Message.Has_Nan_Float then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Float (The_Coded_Output_Stream, 19, The_Message.Nan_Float);
    end if;
    -- optional string cpp_trigraph = 20 [default = "? ? ?? ?? ??? ??/ ??-"];
    if The_Message.Has_Cpp_Trigraph then
      The_Coded_Output_Stream.Write_String (20, The_Message.Cpp_Trigraph.all);
    end if;
    -- optional int32 really_small_int32 = 21 [default = -2147483648];
    if The_Message.Has_Really_Small_Int32 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Integer_32 (The_Coded_Output_Stream, 21, The_Message.Really_Small_Int32);
    end if;
    -- optional int64 really_small_int64 = 22 [default = -9223372036854775808];
    if The_Message.Has_Really_Small_Int64 then
      Protocol_Buffers.IO.Coded_Output_Stream.Write_Integer_64 (The_Coded_Output_Stream, 22, The_Message.Really_Small_Int64);
    end if;
    -- optional string string_with_zero = 23 [default = "hel\000lo"];
    if The_Message.Has_String_With_Zero then
      The_Coded_Output_Stream.Write_String (23, The_Message.String_With_Zero.all);
    end if;
    -- optional bytes bytes_with_zero = 24 [default = "wor\000ld"];
    if The_Message.Has_Bytes_With_Zero then
      The_Coded_Output_Stream.Write_String (24, The_Message.Bytes_With_Zero.all);
    end if;
    -- optional string string_piece_with_zero = 25 [default = "ab\000c", ctype = STRING_PIECE];
    if The_Message.Has_String_Piece_With_Zero then
      The_Coded_Output_Stream.Write_String (25, The_Message.String_Piece_With_Zero.all);
    end if;
    -- optional string cord_with_zero = 26 [default = "12\0003", ctype = CORD];
    if The_Message.Has_Cord_With_Zero then
      The_Coded_Output_Stream.Write_String (26, The_Message.Cord_With_Zero.all);
    end if;
  end Serialize_With_Cached_Sizes;

  procedure Merge_Partial_From_Coded_Input_Stream
    (The_Message   : in out Unittest.TestExtremeDefaultValues.Instance;
     The_Coded_Input_Stream : in out
       Protocol_Buffers.IO.Coded_Input_Stream.Instance) is
    Tag : Protocol_Buffers.Wire_Format.PB_UInt32;
  begin
    Tag := The_Coded_Input_Stream.Read_Tag;
    while Tag /= 0 loop
      case Protocol_Buffers.Wire_Format.Get_Tag_Field_Number (Tag) is
      -- optional bytes escaped_bytes = 1 [default = "\000\001\007\010\014\n\r\t\013\\\'\"\376"];
      when 1 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
          begin
            if The_Message.Escaped_Bytes /= Default_Escaped_Bytes'Access then
              Free (The_Message.Escaped_Bytes);
            end if;
          end;
          The_Message.Set_Has_Escaped_Bytes;
          The_Message.Escaped_Bytes := The_Coded_Input_Stream.Read_String;
        end if;
      -- optional uint32 large_uint32 = 2 [default = 4294967295];
      when 2 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Large_Uint32 := The_Coded_Input_Stream.Read_Unsigned_Integer_32;
          The_Message.Set_Has_Large_Uint32;
        end if;
      -- optional uint64 large_uint64 = 3 [default = 18446744073709551615];
      when 3 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Large_Uint64 := The_Coded_Input_Stream.Read_Unsigned_Integer_64;
          The_Message.Set_Has_Large_Uint64;
        end if;
      -- optional int32 small_int32 = 4 [default = -2147483647];
      when 4 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Small_Int32 := The_Coded_Input_Stream.Read_Integer_32;
          The_Message.Set_Has_Small_Int32;
        end if;
      -- optional int64 small_int64 = 5 [default = -9223372036854775807];
      when 5 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Small_Int64 := The_Coded_Input_Stream.Read_Integer_64;
          The_Message.Set_Has_Small_Int64;
        end if;
      -- optional string utf8_string = 6 [default = "\341\210\264"];
      when 6 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
          begin
            if The_Message.Utf8_String /= Default_Utf8_String'Access then
              Free (The_Message.Utf8_String);
            end if;
          end;
          The_Message.Set_Has_Utf8_String;
          The_Message.Utf8_String := The_Coded_Input_Stream.Read_String;
        end if;
      -- optional float zero_float = 7 [default = 0];
      when 7 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.Zero_Float := The_Coded_Input_Stream.Read_Float;
          The_Message.Set_Has_Zero_Float;
        end if;
      -- optional float one_float = 8 [default = 1];
      when 8 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.One_Float := The_Coded_Input_Stream.Read_Float;
          The_Message.Set_Has_One_Float;
        end if;
      -- optional float small_float = 9 [default = 1.5];
      when 9 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.Small_Float := The_Coded_Input_Stream.Read_Float;
          The_Message.Set_Has_Small_Float;
        end if;
      -- optional float negative_one_float = 10 [default = -1];
      when 10 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.Negative_One_Float := The_Coded_Input_Stream.Read_Float;
          The_Message.Set_Has_Negative_One_Float;
        end if;
      -- optional float negative_float = 11 [default = -1.5];
      when 11 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.Negative_Float := The_Coded_Input_Stream.Read_Float;
          The_Message.Set_Has_Negative_Float;
        end if;
      -- optional float large_float = 12 [default = 2e+08];
      when 12 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.Large_Float := The_Coded_Input_Stream.Read_Float;
          The_Message.Set_Has_Large_Float;
        end if;
      -- optional float small_negative_float = 13 [default = -8e-28];
      when 13 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.Small_Negative_Float := The_Coded_Input_Stream.Read_Float;
          The_Message.Set_Has_Small_Negative_Float;
        end if;
      -- optional double inf_double = 14 [default = inf];
      when 14 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_64 then
          The_Message.Inf_Double := The_Coded_Input_Stream.Read_Double;
          The_Message.Set_Has_Inf_Double;
        end if;
      -- optional double neg_inf_double = 15 [default = -inf];
      when 15 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_64 then
          The_Message.Neg_Inf_Double := The_Coded_Input_Stream.Read_Double;
          The_Message.Set_Has_Neg_Inf_Double;
        end if;
      -- optional double nan_double = 16 [default = nan];
      when 16 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_64 then
          The_Message.Nan_Double := The_Coded_Input_Stream.Read_Double;
          The_Message.Set_Has_Nan_Double;
        end if;
      -- optional float inf_float = 17 [default = inf];
      when 17 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.Inf_Float := The_Coded_Input_Stream.Read_Float;
          The_Message.Set_Has_Inf_Float;
        end if;
      -- optional float neg_inf_float = 18 [default = -inf];
      when 18 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.Neg_Inf_Float := The_Coded_Input_Stream.Read_Float;
          The_Message.Set_Has_Neg_Inf_Float;
        end if;
      -- optional float nan_float = 19 [default = nan];
      when 19 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.FIXED_32 then
          The_Message.Nan_Float := The_Coded_Input_Stream.Read_Float;
          The_Message.Set_Has_Nan_Float;
        end if;
      -- optional string cpp_trigraph = 20 [default = "? ? ?? ?? ??? ??/ ??-"];
      when 20 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
          begin
            if The_Message.Cpp_Trigraph /= Default_Cpp_Trigraph'Access then
              Free (The_Message.Cpp_Trigraph);
            end if;
          end;
          The_Message.Set_Has_Cpp_Trigraph;
          The_Message.Cpp_Trigraph := The_Coded_Input_Stream.Read_String;
        end if;
      -- optional int32 really_small_int32 = 21 [default = -2147483648];
      when 21 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Really_Small_Int32 := The_Coded_Input_Stream.Read_Integer_32;
          The_Message.Set_Has_Really_Small_Int32;
        end if;
      -- optional int64 really_small_int64 = 22 [default = -9223372036854775808];
      when 22 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.VARINT then
          The_Message.Really_Small_Int64 := The_Coded_Input_Stream.Read_Integer_64;
          The_Message.Set_Has_Really_Small_Int64;
        end if;
      -- optional string string_with_zero = 23 [default = "hel\000lo"];
      when 23 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
          begin
            if The_Message.String_With_Zero /= Default_String_With_Zero'Access then
              Free (The_Message.String_With_Zero);
            end if;
          end;
          The_Message.Set_Has_String_With_Zero;
          The_Message.String_With_Zero := The_Coded_Input_Stream.Read_String;
        end if;
      -- optional bytes bytes_with_zero = 24 [default = "wor\000ld"];
      when 24 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
          begin
            if The_Message.Bytes_With_Zero /= Default_Bytes_With_Zero'Access then
              Free (The_Message.Bytes_With_Zero);
            end if;
          end;
          The_Message.Set_Has_Bytes_With_Zero;
          The_Message.Bytes_With_Zero := The_Coded_Input_Stream.Read_String;
        end if;
      -- optional string string_piece_with_zero = 25 [default = "ab\000c", ctype = STRING_PIECE];
      when 25 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
          begin
            if The_Message.String_Piece_With_Zero /= Default_String_Piece_With_Zero'Access then
              Free (The_Message.String_Piece_With_Zero);
            end if;
          end;
          The_Message.Set_Has_String_Piece_With_Zero;
          The_Message.String_Piece_With_Zero := The_Coded_Input_Stream.Read_String;
        end if;
      -- optional string cord_with_zero = 26 [default = "12\0003", ctype = CORD];
      when 26 =>
        if Protocol_Buffers.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Protocol_Buffers.Wire_Format.LENGTH_DELIMITED then
          declare
            procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
          begin
            if The_Message.Cord_With_Zero /= Default_Cord_With_Zero'Access then
              Free (The_Message.Cord_With_Zero);
            end if;
          end;
          The_Message.Set_Has_Cord_With_Zero;
          The_Message.Cord_With_Zero := The_Coded_Input_Stream.Read_String;
        end if;
      when others =>
        declare
          Dummy : Protocol_Buffers.Wire_Format.PB_Bool;
          pragma Unreferenced (Dummy);
        begin
          Dummy := The_Coded_Input_Stream.Skip_Field (Tag);
          return;
        end;
      end case;
      Tag := The_Coded_Input_Stream.Read_Tag;
    end loop;
  end Merge_Partial_From_Coded_Input_Stream;

  function Get_Cached_Size
    (The_Message : in Unittest.TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_Object_Size is
  begin
    return The_Message.Cached_Size;
  end Get_Cached_Size;

  overriding
  procedure Finalize
    (The_Message : in out Unittest.TestExtremeDefaultValues.Instance) is
  begin
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Escaped_Bytes /= Default_Escaped_Bytes'Access then
        Free (The_Message.Escaped_Bytes);
      end if;
    end;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Utf8_String /= Default_Utf8_String'Access then
        Free (The_Message.Utf8_String);
      end if;
    end;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Cpp_Trigraph /= Default_Cpp_Trigraph'Access then
        Free (The_Message.Cpp_Trigraph);
      end if;
    end;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.String_With_Zero /= Default_String_With_Zero'Access then
        Free (The_Message.String_With_Zero);
      end if;
    end;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Bytes_With_Zero /= Default_Bytes_With_Zero'Access then
        Free (The_Message.Bytes_With_Zero);
      end if;
    end;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.String_Piece_With_Zero /= Default_String_Piece_With_Zero'Access then
        Free (The_Message.String_Piece_With_Zero);
      end if;
    end;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Cord_With_Zero /= Default_Cord_With_Zero'Access then
        Free (The_Message.Cord_With_Zero);
      end if;
    end;
  end Finalize;

  ---------------------------------------------------------------------------
  -- Field accessor definitions ---------------------------------------------
  ---------------------------------------------------------------------------

  -- optional bytes escaped_bytes = 1 [default = "\000\001\007\010\014\n\r\t\013\\\'\"\376"];
  function Has_Escaped_Bytes
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000001#) /= 0;
  end Has_Escaped_Bytes;

  procedure Set_Has_Escaped_Bytes
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000001#;
  end Set_Has_Escaped_Bytes;

  procedure Clear_Has_Escaped_Bytes
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000001#);
  end Clear_Has_Escaped_Bytes;

  procedure Clear_Escaped_Bytes
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Clear_Has_Escaped_Bytes;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Escaped_Bytes /= Default_Escaped_Bytes'Access then
        Free (The_Message.Escaped_Bytes);
      end if;
    end;
    The_Message.Escaped_Bytes := Default_Escaped_Bytes'Access;
    The_Message.Clear_Has_Escaped_Bytes;
  end Clear_Escaped_Bytes;

  function Get_Escaped_Bytes
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.Escaped_Bytes.all;
  end Get_Escaped_Bytes;

  function Get_Escaped_Bytes
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Size : in Integer := -1) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Set_Has_Escaped_Bytes;
    if Size >= 0 then
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Escaped_Bytes /= Default_Escaped_Bytes'Access then
          Free (The_Message.Escaped_Bytes);
        end if;
      end;
      The_Message.Escaped_Bytes := new Protocol_Buffers.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
      return The_Message.Escaped_Bytes;
    end if;

    if The_Message.Escaped_Bytes = Default_Escaped_Bytes'Access then
      The_Message.Escaped_Bytes := new String'(Default_Escaped_Bytes);
    end if;
    return The_Message.Escaped_Bytes;
  end Get_Escaped_Bytes;

  procedure Set_Escaped_Bytes
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Set_Has_Escaped_Bytes;
    if The_Message.Escaped_Bytes /= Default_Escaped_Bytes'Access and then Value'Length = The_Message.Escaped_Bytes.all'Length then
      The_Message.Escaped_Bytes.all := Value;
    else
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Escaped_Bytes /= Default_Escaped_Bytes'Access then
          Free (The_Message.Escaped_Bytes);
        end if;
      end;
      The_Message.Escaped_Bytes := new Protocol_Buffers.Wire_Format.PB_String'(Value);
    end if;
  end Set_Escaped_Bytes;

  function Release_Escaped_Bytes
    (The_Message : in out TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Clear_Has_Escaped_Bytes;
    if The_Message.Escaped_Bytes = Default_Escaped_Bytes'Access then
      return null;
    else
      declare
        Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.Escaped_Bytes;
      begin
        The_Message.Escaped_Bytes := Default_Escaped_Bytes'Access;
        return Temp;
      end;
    end if;
  end Release_Escaped_Bytes;

  -- optional uint32 large_uint32 = 2 [default = 4294967295];
  function Has_Large_Uint32
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000002#) /= 0;
  end Has_Large_Uint32;

  procedure Set_Has_Large_Uint32
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000002#;
  end Set_Has_Large_Uint32;

  procedure Clear_Has_Large_Uint32
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000002#);
  end Clear_Has_Large_Uint32;

  procedure Clear_Large_Uint32
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Large_Uint32 := 4294967295;
    The_Message.Clear_Has_Large_Uint32;
  end Clear_Large_Uint32;

  function Get_Large_Uint32
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_UInt32 is
  begin
    return The_Message.Large_Uint32;
  end Get_Large_Uint32;

  procedure Set_Large_Uint32
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_UInt32) is
  begin
    The_Message.Set_Has_Large_Uint32;
    The_Message.Large_Uint32 := Value;
  end Set_Large_Uint32;

  -- optional uint64 large_uint64 = 3 [default = 18446744073709551615];
  function Has_Large_Uint64
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000004#) /= 0;
  end Has_Large_Uint64;

  procedure Set_Has_Large_Uint64
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000004#;
  end Set_Has_Large_Uint64;

  procedure Clear_Has_Large_Uint64
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000004#);
  end Clear_Has_Large_Uint64;

  procedure Clear_Large_Uint64
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Large_Uint64 := 18446744073709551615;
    The_Message.Clear_Has_Large_Uint64;
  end Clear_Large_Uint64;

  function Get_Large_Uint64
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_UInt64 is
  begin
    return The_Message.Large_Uint64;
  end Get_Large_Uint64;

  procedure Set_Large_Uint64
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_UInt64) is
  begin
    The_Message.Set_Has_Large_Uint64;
    The_Message.Large_Uint64 := Value;
  end Set_Large_Uint64;

  -- optional int32 small_int32 = 4 [default = -2147483647];
  function Has_Small_Int32
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000008#) /= 0;
  end Has_Small_Int32;

  procedure Set_Has_Small_Int32
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000008#;
  end Set_Has_Small_Int32;

  procedure Clear_Has_Small_Int32
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000008#);
  end Clear_Has_Small_Int32;

  procedure Clear_Small_Int32
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Small_Int32 := -2147483647;
    The_Message.Clear_Has_Small_Int32;
  end Clear_Small_Int32;

  function Get_Small_Int32
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_Int32 is
  begin
    return The_Message.Small_Int32;
  end Get_Small_Int32;

  procedure Set_Small_Int32
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int32) is
  begin
    The_Message.Set_Has_Small_Int32;
    The_Message.Small_Int32 := Value;
  end Set_Small_Int32;

  -- optional int64 small_int64 = 5 [default = -9223372036854775807];
  function Has_Small_Int64
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000010#) /= 0;
  end Has_Small_Int64;

  procedure Set_Has_Small_Int64
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000010#;
  end Set_Has_Small_Int64;

  procedure Clear_Has_Small_Int64
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000010#);
  end Clear_Has_Small_Int64;

  procedure Clear_Small_Int64
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Small_Int64 := -9223372036854775807;
    The_Message.Clear_Has_Small_Int64;
  end Clear_Small_Int64;

  function Get_Small_Int64
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_Int64 is
  begin
    return The_Message.Small_Int64;
  end Get_Small_Int64;

  procedure Set_Small_Int64
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int64) is
  begin
    The_Message.Set_Has_Small_Int64;
    The_Message.Small_Int64 := Value;
  end Set_Small_Int64;

  -- optional int32 really_small_int32 = 21 [default = -2147483648];
  function Has_Really_Small_Int32
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000020#) /= 0;
  end Has_Really_Small_Int32;

  procedure Set_Has_Really_Small_Int32
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000020#;
  end Set_Has_Really_Small_Int32;

  procedure Clear_Has_Really_Small_Int32
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000020#);
  end Clear_Has_Really_Small_Int32;

  procedure Clear_Really_Small_Int32
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Really_Small_Int32 := -2147483648;
    The_Message.Clear_Has_Really_Small_Int32;
  end Clear_Really_Small_Int32;

  function Get_Really_Small_Int32
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_Int32 is
  begin
    return The_Message.Really_Small_Int32;
  end Get_Really_Small_Int32;

  procedure Set_Really_Small_Int32
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int32) is
  begin
    The_Message.Set_Has_Really_Small_Int32;
    The_Message.Really_Small_Int32 := Value;
  end Set_Really_Small_Int32;

  -- optional int64 really_small_int64 = 22 [default = -9223372036854775808];
  function Has_Really_Small_Int64
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000040#) /= 0;
  end Has_Really_Small_Int64;

  procedure Set_Has_Really_Small_Int64
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000040#;
  end Set_Has_Really_Small_Int64;

  procedure Clear_Has_Really_Small_Int64
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000040#);
  end Clear_Has_Really_Small_Int64;

  procedure Clear_Really_Small_Int64
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Really_Small_Int64 := -9223372036854775808;
    The_Message.Clear_Has_Really_Small_Int64;
  end Clear_Really_Small_Int64;

  function Get_Really_Small_Int64
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_Int64 is
  begin
    return The_Message.Really_Small_Int64;
  end Get_Really_Small_Int64;

  procedure Set_Really_Small_Int64
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Int64) is
  begin
    The_Message.Set_Has_Really_Small_Int64;
    The_Message.Really_Small_Int64 := Value;
  end Set_Really_Small_Int64;

  -- optional string utf8_string = 6 [default = "\341\210\264"];
  function Has_Utf8_String
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000080#) /= 0;
  end Has_Utf8_String;

  procedure Set_Has_Utf8_String
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000080#;
  end Set_Has_Utf8_String;

  procedure Clear_Has_Utf8_String
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000080#);
  end Clear_Has_Utf8_String;

  procedure Clear_Utf8_String
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Clear_Has_Utf8_String;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Utf8_String /= Default_Utf8_String'Access then
        Free (The_Message.Utf8_String);
      end if;
    end;
    The_Message.Utf8_String := Default_Utf8_String'Access;
    The_Message.Clear_Has_Utf8_String;
  end Clear_Utf8_String;

  function Get_Utf8_String
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.Utf8_String.all;
  end Get_Utf8_String;

  function Get_Utf8_String
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Size : in Integer := -1) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Set_Has_Utf8_String;
    if Size >= 0 then
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Utf8_String /= Default_Utf8_String'Access then
          Free (The_Message.Utf8_String);
        end if;
      end;
      The_Message.Utf8_String := new Protocol_Buffers.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
      return The_Message.Utf8_String;
    end if;

    if The_Message.Utf8_String = Default_Utf8_String'Access then
      The_Message.Utf8_String := new String'(Default_Utf8_String);
    end if;
    return The_Message.Utf8_String;
  end Get_Utf8_String;

  procedure Set_Utf8_String
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Set_Has_Utf8_String;
    if The_Message.Utf8_String /= Default_Utf8_String'Access and then Value'Length = The_Message.Utf8_String.all'Length then
      The_Message.Utf8_String.all := Value;
    else
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Utf8_String /= Default_Utf8_String'Access then
          Free (The_Message.Utf8_String);
        end if;
      end;
      The_Message.Utf8_String := new Protocol_Buffers.Wire_Format.PB_String'(Value);
    end if;
  end Set_Utf8_String;

  function Release_Utf8_String
    (The_Message : in out TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Clear_Has_Utf8_String;
    if The_Message.Utf8_String = Default_Utf8_String'Access then
      return null;
    else
      declare
        Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.Utf8_String;
      begin
        The_Message.Utf8_String := Default_Utf8_String'Access;
        return Temp;
      end;
    end if;
  end Release_Utf8_String;

  -- optional float zero_float = 7 [default = 0];
  function Has_Zero_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000100#) /= 0;
  end Has_Zero_Float;

  procedure Set_Has_Zero_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000100#;
  end Set_Has_Zero_Float;

  procedure Clear_Has_Zero_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000100#);
  end Clear_Has_Zero_Float;

  procedure Clear_Zero_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Zero_Float := Protocol_Buffers.Wire_Format.PB_Float (0.00000);
    The_Message.Clear_Has_Zero_Float;
  end Clear_Zero_Float;

  function Get_Zero_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_Float is
  begin
    return The_Message.Zero_Float;
  end Get_Zero_Float;

  procedure Set_Zero_Float
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Float) is
  begin
    The_Message.Set_Has_Zero_Float;
    The_Message.Zero_Float := Value;
  end Set_Zero_Float;

  -- optional float one_float = 8 [default = 1];
  function Has_One_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000200#) /= 0;
  end Has_One_Float;

  procedure Set_Has_One_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000200#;
  end Set_Has_One_Float;

  procedure Clear_Has_One_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000200#);
  end Clear_Has_One_Float;

  procedure Clear_One_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.One_Float := Protocol_Buffers.Wire_Format.PB_Float (1.00000);
    The_Message.Clear_Has_One_Float;
  end Clear_One_Float;

  function Get_One_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_Float is
  begin
    return The_Message.One_Float;
  end Get_One_Float;

  procedure Set_One_Float
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Float) is
  begin
    The_Message.Set_Has_One_Float;
    The_Message.One_Float := Value;
  end Set_One_Float;

  -- optional float small_float = 9 [default = 1.5];
  function Has_Small_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000400#) /= 0;
  end Has_Small_Float;

  procedure Set_Has_Small_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000400#;
  end Set_Has_Small_Float;

  procedure Clear_Has_Small_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000400#);
  end Clear_Has_Small_Float;

  procedure Clear_Small_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Small_Float := Protocol_Buffers.Wire_Format.PB_Float (1.50000);
    The_Message.Clear_Has_Small_Float;
  end Clear_Small_Float;

  function Get_Small_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_Float is
  begin
    return The_Message.Small_Float;
  end Get_Small_Float;

  procedure Set_Small_Float
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Float) is
  begin
    The_Message.Set_Has_Small_Float;
    The_Message.Small_Float := Value;
  end Set_Small_Float;

  -- optional float negative_one_float = 10 [default = -1];
  function Has_Negative_One_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00000800#) /= 0;
  end Has_Negative_One_Float;

  procedure Set_Has_Negative_One_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000800#;
  end Set_Has_Negative_One_Float;

  procedure Clear_Has_Negative_One_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000800#);
  end Clear_Has_Negative_One_Float;

  procedure Clear_Negative_One_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Negative_One_Float := Protocol_Buffers.Wire_Format.PB_Float (-1.00000);
    The_Message.Clear_Has_Negative_One_Float;
  end Clear_Negative_One_Float;

  function Get_Negative_One_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_Float is
  begin
    return The_Message.Negative_One_Float;
  end Get_Negative_One_Float;

  procedure Set_Negative_One_Float
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Float) is
  begin
    The_Message.Set_Has_Negative_One_Float;
    The_Message.Negative_One_Float := Value;
  end Set_Negative_One_Float;

  -- optional float negative_float = 11 [default = -1.5];
  function Has_Negative_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00001000#) /= 0;
  end Has_Negative_Float;

  procedure Set_Has_Negative_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00001000#;
  end Set_Has_Negative_Float;

  procedure Clear_Has_Negative_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00001000#);
  end Clear_Has_Negative_Float;

  procedure Clear_Negative_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Negative_Float := Protocol_Buffers.Wire_Format.PB_Float (-1.50000);
    The_Message.Clear_Has_Negative_Float;
  end Clear_Negative_Float;

  function Get_Negative_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_Float is
  begin
    return The_Message.Negative_Float;
  end Get_Negative_Float;

  procedure Set_Negative_Float
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Float) is
  begin
    The_Message.Set_Has_Negative_Float;
    The_Message.Negative_Float := Value;
  end Set_Negative_Float;

  -- optional float large_float = 12 [default = 2e+08];
  function Has_Large_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00002000#) /= 0;
  end Has_Large_Float;

  procedure Set_Has_Large_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00002000#;
  end Set_Has_Large_Float;

  procedure Clear_Has_Large_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00002000#);
  end Clear_Has_Large_Float;

  procedure Clear_Large_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Large_Float := Protocol_Buffers.Wire_Format.PB_Float (2.00000e+08);
    The_Message.Clear_Has_Large_Float;
  end Clear_Large_Float;

  function Get_Large_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_Float is
  begin
    return The_Message.Large_Float;
  end Get_Large_Float;

  procedure Set_Large_Float
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Float) is
  begin
    The_Message.Set_Has_Large_Float;
    The_Message.Large_Float := Value;
  end Set_Large_Float;

  -- optional float small_negative_float = 13 [default = -8e-28];
  function Has_Small_Negative_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00004000#) /= 0;
  end Has_Small_Negative_Float;

  procedure Set_Has_Small_Negative_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00004000#;
  end Set_Has_Small_Negative_Float;

  procedure Clear_Has_Small_Negative_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00004000#);
  end Clear_Has_Small_Negative_Float;

  procedure Clear_Small_Negative_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Small_Negative_Float := Protocol_Buffers.Wire_Format.PB_Float (-8.00000e-28);
    The_Message.Clear_Has_Small_Negative_Float;
  end Clear_Small_Negative_Float;

  function Get_Small_Negative_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_Float is
  begin
    return The_Message.Small_Negative_Float;
  end Get_Small_Negative_Float;

  procedure Set_Small_Negative_Float
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Float) is
  begin
    The_Message.Set_Has_Small_Negative_Float;
    The_Message.Small_Negative_Float := Value;
  end Set_Small_Negative_Float;

  -- optional double inf_double = 14 [default = inf];
  function Has_Inf_Double
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00008000#) /= 0;
  end Has_Inf_Double;

  procedure Set_Has_Inf_Double
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00008000#;
  end Set_Has_Inf_Double;

  procedure Clear_Has_Inf_Double
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00008000#);
  end Clear_Has_Inf_Double;

  procedure Clear_Inf_Double
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Inf_Double := Protocol_Buffers.Generated_Message_Utilities.Positive_Infinity;
    The_Message.Clear_Has_Inf_Double;
  end Clear_Inf_Double;

  function Get_Inf_Double
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_Double is
  begin
    return The_Message.Inf_Double;
  end Get_Inf_Double;

  procedure Set_Inf_Double
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Double) is
  begin
    The_Message.Set_Has_Inf_Double;
    The_Message.Inf_Double := Value;
  end Set_Inf_Double;

  -- optional double neg_inf_double = 15 [default = -inf];
  function Has_Neg_Inf_Double
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00010000#) /= 0;
  end Has_Neg_Inf_Double;

  procedure Set_Has_Neg_Inf_Double
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00010000#;
  end Set_Has_Neg_Inf_Double;

  procedure Clear_Has_Neg_Inf_Double
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00010000#);
  end Clear_Has_Neg_Inf_Double;

  procedure Clear_Neg_Inf_Double
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Neg_Inf_Double := Protocol_Buffers.Generated_Message_Utilities.Negative_Infinity;
    The_Message.Clear_Has_Neg_Inf_Double;
  end Clear_Neg_Inf_Double;

  function Get_Neg_Inf_Double
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_Double is
  begin
    return The_Message.Neg_Inf_Double;
  end Get_Neg_Inf_Double;

  procedure Set_Neg_Inf_Double
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Double) is
  begin
    The_Message.Set_Has_Neg_Inf_Double;
    The_Message.Neg_Inf_Double := Value;
  end Set_Neg_Inf_Double;

  -- optional double nan_double = 16 [default = nan];
  function Has_Nan_Double
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00020000#) /= 0;
  end Has_Nan_Double;

  procedure Set_Has_Nan_Double
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00020000#;
  end Set_Has_Nan_Double;

  procedure Clear_Has_Nan_Double
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00020000#);
  end Clear_Has_Nan_Double;

  procedure Clear_Nan_Double
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Nan_Double := Protocol_Buffers.Generated_Message_Utilities.NaN;
    The_Message.Clear_Has_Nan_Double;
  end Clear_Nan_Double;

  function Get_Nan_Double
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_Double is
  begin
    return The_Message.Nan_Double;
  end Get_Nan_Double;

  procedure Set_Nan_Double
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Double) is
  begin
    The_Message.Set_Has_Nan_Double;
    The_Message.Nan_Double := Value;
  end Set_Nan_Double;

  -- optional float inf_float = 17 [default = inf];
  function Has_Inf_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00040000#) /= 0;
  end Has_Inf_Float;

  procedure Set_Has_Inf_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00040000#;
  end Set_Has_Inf_Float;

  procedure Clear_Has_Inf_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00040000#);
  end Clear_Has_Inf_Float;

  procedure Clear_Inf_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Inf_Float := Protocol_Buffers.Generated_Message_Utilities.Positive_Infinity;
    The_Message.Clear_Has_Inf_Float;
  end Clear_Inf_Float;

  function Get_Inf_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_Float is
  begin
    return The_Message.Inf_Float;
  end Get_Inf_Float;

  procedure Set_Inf_Float
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Float) is
  begin
    The_Message.Set_Has_Inf_Float;
    The_Message.Inf_Float := Value;
  end Set_Inf_Float;

  -- optional float neg_inf_float = 18 [default = -inf];
  function Has_Neg_Inf_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00080000#) /= 0;
  end Has_Neg_Inf_Float;

  procedure Set_Has_Neg_Inf_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00080000#;
  end Set_Has_Neg_Inf_Float;

  procedure Clear_Has_Neg_Inf_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00080000#);
  end Clear_Has_Neg_Inf_Float;

  procedure Clear_Neg_Inf_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Neg_Inf_Float := Protocol_Buffers.Generated_Message_Utilities.Negative_Infinity;
    The_Message.Clear_Has_Neg_Inf_Float;
  end Clear_Neg_Inf_Float;

  function Get_Neg_Inf_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_Float is
  begin
    return The_Message.Neg_Inf_Float;
  end Get_Neg_Inf_Float;

  procedure Set_Neg_Inf_Float
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Float) is
  begin
    The_Message.Set_Has_Neg_Inf_Float;
    The_Message.Neg_Inf_Float := Value;
  end Set_Neg_Inf_Float;

  -- optional float nan_float = 19 [default = nan];
  function Has_Nan_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00100000#) /= 0;
  end Has_Nan_Float;

  procedure Set_Has_Nan_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00100000#;
  end Set_Has_Nan_Float;

  procedure Clear_Has_Nan_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00100000#);
  end Clear_Has_Nan_Float;

  procedure Clear_Nan_Float
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Nan_Float := Protocol_Buffers.Generated_Message_Utilities.NaN;
    The_Message.Clear_Has_Nan_Float;
  end Clear_Nan_Float;

  function Get_Nan_Float
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_Float is
  begin
    return The_Message.Nan_Float;
  end Get_Nan_Float;

  procedure Set_Nan_Float
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_Float) is
  begin
    The_Message.Set_Has_Nan_Float;
    The_Message.Nan_Float := Value;
  end Set_Nan_Float;

  -- optional string cpp_trigraph = 20 [default = "? ? ?? ?? ??? ??/ ??-"];
  function Has_Cpp_Trigraph
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00200000#) /= 0;
  end Has_Cpp_Trigraph;

  procedure Set_Has_Cpp_Trigraph
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00200000#;
  end Set_Has_Cpp_Trigraph;

  procedure Clear_Has_Cpp_Trigraph
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00200000#);
  end Clear_Has_Cpp_Trigraph;

  procedure Clear_Cpp_Trigraph
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Clear_Has_Cpp_Trigraph;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Cpp_Trigraph /= Default_Cpp_Trigraph'Access then
        Free (The_Message.Cpp_Trigraph);
      end if;
    end;
    The_Message.Cpp_Trigraph := Default_Cpp_Trigraph'Access;
    The_Message.Clear_Has_Cpp_Trigraph;
  end Clear_Cpp_Trigraph;

  function Get_Cpp_Trigraph
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.Cpp_Trigraph.all;
  end Get_Cpp_Trigraph;

  function Get_Cpp_Trigraph
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Size : in Integer := -1) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Set_Has_Cpp_Trigraph;
    if Size >= 0 then
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Cpp_Trigraph /= Default_Cpp_Trigraph'Access then
          Free (The_Message.Cpp_Trigraph);
        end if;
      end;
      The_Message.Cpp_Trigraph := new Protocol_Buffers.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
      return The_Message.Cpp_Trigraph;
    end if;

    if The_Message.Cpp_Trigraph = Default_Cpp_Trigraph'Access then
      The_Message.Cpp_Trigraph := new String'(Default_Cpp_Trigraph);
    end if;
    return The_Message.Cpp_Trigraph;
  end Get_Cpp_Trigraph;

  procedure Set_Cpp_Trigraph
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Set_Has_Cpp_Trigraph;
    if The_Message.Cpp_Trigraph /= Default_Cpp_Trigraph'Access and then Value'Length = The_Message.Cpp_Trigraph.all'Length then
      The_Message.Cpp_Trigraph.all := Value;
    else
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Cpp_Trigraph /= Default_Cpp_Trigraph'Access then
          Free (The_Message.Cpp_Trigraph);
        end if;
      end;
      The_Message.Cpp_Trigraph := new Protocol_Buffers.Wire_Format.PB_String'(Value);
    end if;
  end Set_Cpp_Trigraph;

  function Release_Cpp_Trigraph
    (The_Message : in out TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Clear_Has_Cpp_Trigraph;
    if The_Message.Cpp_Trigraph = Default_Cpp_Trigraph'Access then
      return null;
    else
      declare
        Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.Cpp_Trigraph;
      begin
        The_Message.Cpp_Trigraph := Default_Cpp_Trigraph'Access;
        return Temp;
      end;
    end if;
  end Release_Cpp_Trigraph;

  -- optional string string_with_zero = 23 [default = "hel\000lo"];
  function Has_String_With_Zero
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00400000#) /= 0;
  end Has_String_With_Zero;

  procedure Set_Has_String_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00400000#;
  end Set_Has_String_With_Zero;

  procedure Clear_Has_String_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00400000#);
  end Clear_Has_String_With_Zero;

  procedure Clear_String_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Clear_Has_String_With_Zero;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.String_With_Zero /= Default_String_With_Zero'Access then
        Free (The_Message.String_With_Zero);
      end if;
    end;
    The_Message.String_With_Zero := Default_String_With_Zero'Access;
    The_Message.Clear_Has_String_With_Zero;
  end Clear_String_With_Zero;

  function Get_String_With_Zero
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.String_With_Zero.all;
  end Get_String_With_Zero;

  function Get_String_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Size : in Integer := -1) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Set_Has_String_With_Zero;
    if Size >= 0 then
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.String_With_Zero /= Default_String_With_Zero'Access then
          Free (The_Message.String_With_Zero);
        end if;
      end;
      The_Message.String_With_Zero := new Protocol_Buffers.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
      return The_Message.String_With_Zero;
    end if;

    if The_Message.String_With_Zero = Default_String_With_Zero'Access then
      The_Message.String_With_Zero := new String'(Default_String_With_Zero);
    end if;
    return The_Message.String_With_Zero;
  end Get_String_With_Zero;

  procedure Set_String_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Set_Has_String_With_Zero;
    if The_Message.String_With_Zero /= Default_String_With_Zero'Access and then Value'Length = The_Message.String_With_Zero.all'Length then
      The_Message.String_With_Zero.all := Value;
    else
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.String_With_Zero /= Default_String_With_Zero'Access then
          Free (The_Message.String_With_Zero);
        end if;
      end;
      The_Message.String_With_Zero := new Protocol_Buffers.Wire_Format.PB_String'(Value);
    end if;
  end Set_String_With_Zero;

  function Release_String_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Clear_Has_String_With_Zero;
    if The_Message.String_With_Zero = Default_String_With_Zero'Access then
      return null;
    else
      declare
        Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.String_With_Zero;
      begin
        The_Message.String_With_Zero := Default_String_With_Zero'Access;
        return Temp;
      end;
    end if;
  end Release_String_With_Zero;

  -- optional bytes bytes_with_zero = 24 [default = "wor\000ld"];
  function Has_Bytes_With_Zero
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#00800000#) /= 0;
  end Has_Bytes_With_Zero;

  procedure Set_Has_Bytes_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00800000#;
  end Set_Has_Bytes_With_Zero;

  procedure Clear_Has_Bytes_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00800000#);
  end Clear_Has_Bytes_With_Zero;

  procedure Clear_Bytes_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Clear_Has_Bytes_With_Zero;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Bytes_With_Zero /= Default_Bytes_With_Zero'Access then
        Free (The_Message.Bytes_With_Zero);
      end if;
    end;
    The_Message.Bytes_With_Zero := Default_Bytes_With_Zero'Access;
    The_Message.Clear_Has_Bytes_With_Zero;
  end Clear_Bytes_With_Zero;

  function Get_Bytes_With_Zero
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.Bytes_With_Zero.all;
  end Get_Bytes_With_Zero;

  function Get_Bytes_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Size : in Integer := -1) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Set_Has_Bytes_With_Zero;
    if Size >= 0 then
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Bytes_With_Zero /= Default_Bytes_With_Zero'Access then
          Free (The_Message.Bytes_With_Zero);
        end if;
      end;
      The_Message.Bytes_With_Zero := new Protocol_Buffers.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
      return The_Message.Bytes_With_Zero;
    end if;

    if The_Message.Bytes_With_Zero = Default_Bytes_With_Zero'Access then
      The_Message.Bytes_With_Zero := new String'(Default_Bytes_With_Zero);
    end if;
    return The_Message.Bytes_With_Zero;
  end Get_Bytes_With_Zero;

  procedure Set_Bytes_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Set_Has_Bytes_With_Zero;
    if The_Message.Bytes_With_Zero /= Default_Bytes_With_Zero'Access and then Value'Length = The_Message.Bytes_With_Zero.all'Length then
      The_Message.Bytes_With_Zero.all := Value;
    else
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Bytes_With_Zero /= Default_Bytes_With_Zero'Access then
          Free (The_Message.Bytes_With_Zero);
        end if;
      end;
      The_Message.Bytes_With_Zero := new Protocol_Buffers.Wire_Format.PB_String'(Value);
    end if;
  end Set_Bytes_With_Zero;

  function Release_Bytes_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Clear_Has_Bytes_With_Zero;
    if The_Message.Bytes_With_Zero = Default_Bytes_With_Zero'Access then
      return null;
    else
      declare
        Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.Bytes_With_Zero;
      begin
        The_Message.Bytes_With_Zero := Default_Bytes_With_Zero'Access;
        return Temp;
      end;
    end if;
  end Release_Bytes_With_Zero;

  -- optional string string_piece_with_zero = 25 [default = "ab\000c", ctype = STRING_PIECE];
  function Has_String_Piece_With_Zero
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#01000000#) /= 0;
  end Has_String_Piece_With_Zero;

  procedure Set_Has_String_Piece_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#01000000#;
  end Set_Has_String_Piece_With_Zero;

  procedure Clear_Has_String_Piece_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#01000000#);
  end Clear_Has_String_Piece_With_Zero;

  procedure Clear_String_Piece_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Clear_Has_String_Piece_With_Zero;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.String_Piece_With_Zero /= Default_String_Piece_With_Zero'Access then
        Free (The_Message.String_Piece_With_Zero);
      end if;
    end;
    The_Message.String_Piece_With_Zero := Default_String_Piece_With_Zero'Access;
    The_Message.Clear_Has_String_Piece_With_Zero;
  end Clear_String_Piece_With_Zero;

  function Get_String_Piece_With_Zero
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.String_Piece_With_Zero.all;
  end Get_String_Piece_With_Zero;

  function Get_String_Piece_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Size : in Integer := -1) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Set_Has_String_Piece_With_Zero;
    if Size >= 0 then
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.String_Piece_With_Zero /= Default_String_Piece_With_Zero'Access then
          Free (The_Message.String_Piece_With_Zero);
        end if;
      end;
      The_Message.String_Piece_With_Zero := new Protocol_Buffers.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
      return The_Message.String_Piece_With_Zero;
    end if;

    if The_Message.String_Piece_With_Zero = Default_String_Piece_With_Zero'Access then
      The_Message.String_Piece_With_Zero := new String'(Default_String_Piece_With_Zero);
    end if;
    return The_Message.String_Piece_With_Zero;
  end Get_String_Piece_With_Zero;

  procedure Set_String_Piece_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Set_Has_String_Piece_With_Zero;
    if The_Message.String_Piece_With_Zero /= Default_String_Piece_With_Zero'Access and then Value'Length = The_Message.String_Piece_With_Zero.all'Length then
      The_Message.String_Piece_With_Zero.all := Value;
    else
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.String_Piece_With_Zero /= Default_String_Piece_With_Zero'Access then
          Free (The_Message.String_Piece_With_Zero);
        end if;
      end;
      The_Message.String_Piece_With_Zero := new Protocol_Buffers.Wire_Format.PB_String'(Value);
    end if;
  end Set_String_Piece_With_Zero;

  function Release_String_Piece_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Clear_Has_String_Piece_With_Zero;
    if The_Message.String_Piece_With_Zero = Default_String_Piece_With_Zero'Access then
      return null;
    else
      declare
        Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.String_Piece_With_Zero;
      begin
        The_Message.String_Piece_With_Zero := Default_String_Piece_With_Zero'Access;
        return Temp;
      end;
    end if;
  end Release_String_Piece_With_Zero;

  -- optional string cord_with_zero = 26 [default = "12\0003", ctype = CORD];
  function Has_Cord_With_Zero
    (The_Message : in TestExtremeDefaultValues.Instance) return Boolean is
  begin
    return (The_Message.Has_Bits(0) and 16#02000000#) /= 0;
  end Has_Cord_With_Zero;

  procedure Set_Has_Cord_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#02000000#;
  end Set_Has_Cord_With_Zero;

  procedure Clear_Has_Cord_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#02000000#);
  end Clear_Has_Cord_With_Zero;

  procedure Clear_Cord_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance) is
  begin
    The_Message.Clear_Has_Cord_With_Zero;
    declare
      procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
    begin
      if The_Message.Cord_With_Zero /= Default_Cord_With_Zero'Access then
        Free (The_Message.Cord_With_Zero);
      end if;
    end;
    The_Message.Cord_With_Zero := Default_Cord_With_Zero'Access;
    The_Message.Clear_Has_Cord_With_Zero;
  end Clear_Cord_With_Zero;

  function Get_Cord_With_Zero
    (The_Message : in TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_String is
  begin
    return The_Message.Cord_With_Zero.all;
  end Get_Cord_With_Zero;

  function Get_Cord_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Size : in Integer := -1) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Set_Has_Cord_With_Zero;
    if Size >= 0 then
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Cord_With_Zero /= Default_Cord_With_Zero'Access then
          Free (The_Message.Cord_With_Zero);
        end if;
      end;
      The_Message.Cord_With_Zero := new Protocol_Buffers.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
      return The_Message.Cord_With_Zero;
    end if;

    if The_Message.Cord_With_Zero = Default_Cord_With_Zero'Access then
      The_Message.Cord_With_Zero := new String'(Default_Cord_With_Zero);
    end if;
    return The_Message.Cord_With_Zero;
  end Get_Cord_With_Zero;

  procedure Set_Cord_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance;
     Value : in Protocol_Buffers.Wire_Format.PB_String) is
  begin
    The_Message.Set_Has_Cord_With_Zero;
    if The_Message.Cord_With_Zero /= Default_Cord_With_Zero'Access and then Value'Length = The_Message.Cord_With_Zero.all'Length then
      The_Message.Cord_With_Zero.all := Value;
    else
      declare
        procedure Free is new Ada.Unchecked_Deallocation (Protocol_Buffers.Wire_Format.PB_String, Protocol_Buffers.Wire_Format.PB_String_Access);
      begin
        if The_Message.Cord_With_Zero /= Default_Cord_With_Zero'Access then
          Free (The_Message.Cord_With_Zero);
        end if;
      end;
      The_Message.Cord_With_Zero := new Protocol_Buffers.Wire_Format.PB_String'(Value);
    end if;
  end Set_Cord_With_Zero;

  function Release_Cord_With_Zero
    (The_Message : in out TestExtremeDefaultValues.Instance) return Protocol_Buffers.Wire_Format.PB_String_Access is
  begin
    The_Message.Clear_Has_Cord_With_Zero;
    if The_Message.Cord_With_Zero = Default_Cord_With_Zero'Access then
      return null;
    else
      declare
        Temp : Protocol_Buffers.Wire_Format.PB_String_Access := The_Message.Cord_With_Zero;
      begin
        The_Message.Cord_With_Zero := Default_Cord_With_Zero'Access;
        return Temp;
      end;
    end if;
  end Release_Cord_With_Zero;

end Unittest.TestExtremeDefaultValues;
